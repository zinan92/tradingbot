#!/usr/bin/env python3
"""
Runner for property-based tests with detailed output and minimal counterexample reporting.

This script runs all property tests and demonstrates:
- Successful property verification
- Failure detection with minimal counterexamples
- Shrinking strategies in action
"""

import sys
import traceback
from decimal import Decimal
from datetime import datetime
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from hypothesis import settings, Verbosity, HealthCheck, Phase, seed
from hypothesis.errors import FailedHealthCheck
from hypothesis.database import DirectoryBasedExampleDatabase

# Import our property tests
from tests.property.test_trading_invariants import (
    TradingProperties, TradingStateMachine
)
from tests.property.test_advanced_invariants import (
    ComplexInvariantTests, MinimalCounterexampleFinder
)


class PropertyTestRunner:
    """Runs property tests with detailed reporting."""
    
    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self.results = []
        
        # Configure Hypothesis settings
        settings.register_profile(
            "dev",
            max_examples=50,
            verbosity=Verbosity.verbose if verbose else Verbosity.normal,
            deadline=10000,
            print_blob=True,
            suppress_health_check=[HealthCheck.too_slow],
            phases=[Phase.explicit, Phase.reuse, Phase.generate, Phase.shrink]
        )
        
        settings.register_profile(
            "ci",
            max_examples=200,
            verbosity=Verbosity.normal,
            deadline=None,
            suppress_health_check=[HealthCheck.too_slow],
            database=DirectoryBasedExampleDatabase(".hypothesis/examples")
        )
        
        settings.load_profile("dev")
    
    def run_test(self, test_name: str, test_func, *args, **kwargs):
        """Run a single property test and report results."""
        print(f"\n{'='*60}")
        print(f"Running: {test_name}")
        print(f"{'='*60}")
        
        try:
            # Run the test
            test_func(*args, **kwargs)
            
            print(f"✅ PASSED: {test_name}")
            self.results.append((test_name, "PASSED", None))
            
        except AssertionError as e:
            print(f"❌ FAILED: {test_name}")
            print(f"Assertion: {str(e)}")
            
            # Try to extract minimal counterexample
            if hasattr(e, '__notes__'):
                print("\nMinimal Counterexample:")
                for note in e.__notes__:
                    print(f"  {note}")
            
            self.results.append((test_name, "FAILED", str(e)))
            
            if self.verbose:
                print("\nFull Traceback:")
                traceback.print_exc()
            
        except Exception as e:
            print(f"⚠️  ERROR: {test_name}")
            print(f"Error: {str(e)}")
            self.results.append((test_name, "ERROR", str(e)))
            
            if self.verbose:
                traceback.print_exc()
    
    def run_all_basic_tests(self):
        """Run all basic property tests."""
        print("\n" + "="*60)
        print("BASIC PROPERTY TESTS")
        print("="*60)
        
        props = TradingProperties()
        
        # Test 1: Free margin
        self.run_test(
            "Free Margin Always Positive",
            props.test_free_margin_always_positive,
            orders=[],  # Will be generated by Hypothesis
            initial_balance=Decimal("10000"),
            leverage=Decimal("10")
        )
        
        # Test 2: Risk blocking
        self.run_test(
            "Risk Blocks Prevent Position Changes",
            props.test_risk_blocks_prevent_position_changes,
            orders=[],
            risk_limit=Decimal("0.5"),
            prices=[Decimal("50000")]
        )
        
        # Test 3: Close all
        self.run_test(
            "Close All Results in Zero Position",
            props.test_close_all_results_in_zero_position,
            orders=[],
            final_prices={"BTCUSDT": Decimal("50000")}
        )
        
        # Test 4: Exposure limits
        self.run_test(
            "Exposure Never Exceeds Maximum",
            props.test_exposure_never_exceeds_max,
            orders=[],
            max_exposure_limit=Decimal("0.8"),
            account_equity=Decimal("100000"),
            current_price=Decimal("50000")
        )
    
    def run_stateful_tests(self):
        """Run stateful property tests."""
        print("\n" + "="*60)
        print("STATEFUL PROPERTY TESTS")
        print("="*60)
        
        try:
            # Create test case
            test_case = TradingStateMachine.TestCase()
            test_case.runTest()
            
            print("✅ PASSED: Stateful Trading System Test")
            self.results.append(("Stateful Trading System", "PASSED", None))
            
        except Exception as e:
            print(f"❌ FAILED: Stateful Trading System Test")
            print(f"Error: {str(e)}")
            self.results.append(("Stateful Trading System", "FAILED", str(e)))
    
    def run_advanced_tests(self):
        """Run advanced property tests."""
        print("\n" + "="*60)
        print("ADVANCED PROPERTY TESTS")
        print("="*60)
        
        advanced = ComplexInvariantTests()
        
        # Test margin calls
        self.run_test(
            "Margin Call Protection",
            advanced.test_margin_call_protection
        )
        
        # Test concurrent orders
        self.run_test(
            "Concurrent Order Consistency",
            advanced.test_concurrent_order_consistency
        )
        
        # Test PnL calculations
        self.run_test(
            "PnL Calculation Consistency",
            advanced.test_pnl_calculation_consistency
        )
    
    def demonstrate_counterexample(self):
        """Demonstrate minimal counterexample finding."""
        print("\n" + "="*60)
        print("COUNTEREXAMPLE DEMONSTRATION")
        print("="*60)
        
        # Intentionally create a failing scenario
        print("\nCreating intentional failure to demonstrate shrinking...")
        
        def failing_property(orders):
            """Property that will fail with specific input."""
            total = sum(o.get('quantity', 0) for o in orders)
            # This will fail if total quantity > 100
            assert total <= 100, f"Total quantity {total} exceeds limit"
            return total <= 100
        
        # Start with complex failing input
        failing_input = [
            {'quantity': 50, 'symbol': 'BTCUSDT', 'side': 'BUY', 'price': 50000},
            {'quantity': 30, 'symbol': 'ETHUSDT', 'side': 'SELL', 'price': 3000},
            {'quantity': 25, 'symbol': 'BNBUSDT', 'side': 'BUY', 'price': 500},
            {'quantity': 10, 'symbol': 'BTCUSDT', 'side': 'SELL', 'price': 51000},
        ]
        
        print(f"Initial failing input: {len(failing_input)} orders, total quantity: {sum(o['quantity'] for o in failing_input)}")
        
        # Find minimal counterexample
        finder = MinimalCounterexampleFinder()
        
        def simplify(orders):
            """Simplify by removing orders."""
            if len(orders) > 2:
                return orders[:-1]  # Remove last order
            return orders
        
        minimal = finder.binary_search_failure(
            failing_property,
            failing_input,
            simplify
        )
        
        print(f"\nMinimal counterexample: {len(minimal)} orders")
        for i, order in enumerate(minimal):
            print(f"  Order {i+1}: {order['symbol']} {order['side']} {order['quantity']}")
        print(f"Total quantity in minimal: {sum(o['quantity'] for o in minimal)}")
    
    def print_summary(self):
        """Print test summary."""
        print("\n" + "="*60)
        print("TEST SUMMARY")
        print("="*60)
        
        passed = sum(1 for _, status, _ in self.results if status == "PASSED")
        failed = sum(1 for _, status, _ in self.results if status == "FAILED")
        errors = sum(1 for _, status, _ in self.results if status == "ERROR")
        
        print(f"\nTotal Tests: {len(self.results)}")
        print(f"✅ Passed: {passed}")
        print(f"❌ Failed: {failed}")
        print(f"⚠️  Errors: {errors}")
        
        if failed > 0:
            print("\nFailed Tests:")
            for name, status, error in self.results:
                if status == "FAILED":
                    print(f"  - {name}: {error[:100]}...")
        
        if errors > 0:
            print("\nTests with Errors:")
            for name, status, error in self.results:
                if status == "ERROR":
                    print(f"  - {name}: {error[:100]}...")
        
        return failed == 0 and errors == 0


def main():
    """Main entry point."""
    print("🧪 PROPERTY-BASED TESTING FOR TRADING SYSTEM")
    print("=" * 60)
    print("Testing invariants with random data generation")
    print("Hypothesis will generate random test cases and shrink failures")
    print()
    
    # Create runner
    runner = PropertyTestRunner(verbose=False)
    
    # Run tests
    try:
        # Basic properties
        runner.run_all_basic_tests()
        
        # Stateful testing
        runner.run_stateful_tests()
        
        # Advanced properties
        runner.run_advanced_tests()
        
        # Demonstrate counterexample finding
        runner.demonstrate_counterexample()
        
    except KeyboardInterrupt:
        print("\n\nTests interrupted by user")
        return 1
    
    # Print summary
    success = runner.print_summary()
    
    if success:
        print("\n✅ All property tests passed!")
        print("The trading system maintains all invariants under random testing.")
        return 0
    else:
        print("\n❌ Some property tests failed!")
        print("Review the minimal counterexamples above to fix the issues.")
        return 1


if __name__ == "__main__":
    sys.exit(main())